package TurnQuest.view.helper;


import TurnQuest.view.Connect.DBConnector;

import java.math.BigDecimal;

import java.sql.CallableStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;

import javax.faces.context.FacesContext;

import javax.servlet.http.HttpSession;

import oracle.jbo.JboException;
import oracle.jbo.domain.Date;
import oracle.jbo.domain.Number;
import oracle.jbo.server.SQLBuilder;
import oracle.jbo.server.ViewObjectImpl;
import oracle.jbo.server.ViewRowImpl;
import oracle.jbo.server.ViewRowSetImpl;

import oracle.jdbc.OracleTypes;


// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Wed Dec 15 12:13:06 EAT 2010
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class ClientLOVImpl extends ViewObjectImpl {
    /**
     * This is the default constructor (do not remove).
     */
    public ClientLOVImpl() {
    }

    HttpSession session =
        (HttpSession)FacesContext.getCurrentInstance().getExternalContext().getSession(false);

    /**
     * Overridden framework method.
     *
     * Executed when the framework needs to issue the database query for
     * the query collection based on this view object. One view object
     * can produce many related result sets, each potentially the result
     * of different bind variable values. If the rowset in query is involved
     * in a framework-coordinated master/detail viewlink, then the params array
     * will contain one or more framework-supplied bind parameters. If there
     * are any user-supplied bind parameter values, they will *PRECEED* the
     * framework-supplied bind variable values in the params array, and the
     * number of user parameters will be indicated by the value of the
     * numUserParams argument.
     */
    protected void executeQueryForCollection(Object qc, Object[] params,
                                             int numUserParams) {
        storeNewResultSet(qc, retrieveRefCursor(qc, params));
        super.executeQueryForCollection(qc, params, numUserParams);
    }

    /**
     * Overridden framework method.
     *
     * Wipe out all traces of a built-in query for this VO
     */
    protected void create() {
        getViewDef().setQuery(null);
        getViewDef().setSelectClause(null);
        setQuery(null);
    }

    /**
     * Overridden framework method.
     *
     * The role of this method is to "fetch", populate, and return a single row
     * from the datasource by calling createNewRowForCollection() and populating
     * its attributes using populateAttributeForRow().
     */
    protected ViewRowImpl createRowFromResultSet(Object qc,
                                                 ResultSet resultSet) {
        /*
    * We ignore the JDBC ResultSet passed by the framework (null anyway) and
    * use the resultset that we've stored in the query-collection-private
    * user data storage
    */
        resultSet = getResultSet(qc);

        /*
    * Create a new row to populate
    */
        ViewRowImpl r = createNewRowForCollection(qc);

        try {
            /*
      * Populate new row by attribute slot number for current row in Result Set
      */
            populateAttributeForRow(r, 0, resultSet.getString(1));
            populateAttributeForRow(r, 1, resultSet.getString(2));
            populateAttributeForRow(r, 2, resultSet.getString(3));
            populateAttributeForRow(r, 3, resultSet.getString(4));
            populateAttributeForRow(r, 4, resultSet.getString(5));
            populateAttributeForRow(r, 5, resultSet.getDate(6));
            /*populateAttributeForRow(r, 6,resultSet.getString(7));
                  populateAttributeForRow(r, 7,resultSet.getString(8));
                  populateAttributeForRow(r, 8,resultSet.getString(9));
                  populateAttributeForRow(r, 9,resultSet.getString(10));
                  populateAttributeForRow(r, 10,resultSet.getString(11));
                  populateAttributeForRow(r, 11,resultSet.getString(12));
                  populateAttributeForRow(r, 12,resultSet.getString(13));
                  populateAttributeForRow(r, 13,resultSet.getString(14));
                  populateAttributeForRow(r, 14,resultSet.getString(15));
                  populateAttributeForRow(r, 15,resultSet.getString(16));
                  populateAttributeForRow(r, 16,resultSet.getString(17));
                  populateAttributeForRow(r, 17,resultSet.getString(18));
                  populateAttributeForRow(r, 18,resultSet.getString(19));
                  populateAttributeForRow(r, 19,resultSet.getString(20));
                  populateAttributeForRow(r, 20,resultSet.getString(21));
                  populateAttributeForRow(r, 21,resultSet.getString(22));
                  populateAttributeForRow(r, 22,resultSet.getString(23));
                  populateAttributeForRow(r, 23,resultSet.getString(24));
                  populateAttributeForRow(r, 24,resultSet.getString(25));
                  populateAttributeForRow(r, 25,resultSet.getString(26));
                  populateAttributeForRow(r, 26,resultSet.getDate(27));
                  populateAttributeForRow(r, 27,resultSet.getDate(28));
                  populateAttributeForRow(r, 28,resultSet.getString(29));
                  populateAttributeForRow(r, 29,resultSet.getBigDecimal(30));
                  populateAttributeForRow(r, 30,resultSet.getString(31));
                  populateAttributeForRow(r, 31,resultSet.getString(32));
                  populateAttributeForRow(r, 32,resultSet.getString(33));
                  populateAttributeForRow(r, 33,resultSet.getString(34));
                  populateAttributeForRow(r, 34,resultSet.getString(35));
                  populateAttributeForRow(r, 35,resultSet.getString(36));
                  populateAttributeForRow(r, 36,resultSet.getString(37));
                  populateAttributeForRow(r, 37,resultSet.getString(38));
                  populateAttributeForRow(r, 38,resultSet.getString(39));
                  populateAttributeForRow(r, 39,resultSet.getString(40));
                  populateAttributeForRow(r, 40,resultSet.getString(41));
                  populateAttributeForRow(r, 41,resultSet.getString(42));
                  populateAttributeForRow(r, 42,resultSet.getDate(43));
                  populateAttributeForRow(r, 43,resultSet.getString(44));
                  populateAttributeForRow(r, 44,resultSet.getString(45));
                  populateAttributeForRow(r, 45,resultSet.getString(46));
                  populateAttributeForRow(r, 46,resultSet.getString(47));
                  populateAttributeForRow(r, 47,resultSet.getString(48));
                  populateAttributeForRow(r, 48,resultSet.getString(49));
                  populateAttributeForRow(r, 49,resultSet.getString(50));
                  populateAttributeForRow(r, 50,resultSet.getString(51));
                  populateAttributeForRow(r, 51,resultSet.getString(52));
                  populateAttributeForRow(r, 52,resultSet.getString(53));
                  populateAttributeForRow(r, 53,resultSet.getBigDecimal(54));
                  populateAttributeForRow(r, 54,resultSet.getString(55));
                  populateAttributeForRow(r, 55,resultSet.getString(56));
                  populateAttributeForRow(r, 56,resultSet.getString(57));
                  populateAttributeForRow(r, 57,resultSet.getString(58));
                  populateAttributeForRow(r, 58,resultSet.getString(59));
                  populateAttributeForRow(r,59,resultSet.getString(60));
                  populateAttributeForRow(r, 60,resultSet.getString(61));
                  populateAttributeForRow(r, 61,resultSet.getString(62));
                  populateAttributeForRow(r, 62,resultSet.getString(63));
                  populateAttributeForRow(r, 63,resultSet.getString(64));
                  populateAttributeForRow(r, 64,resultSet.getBigDecimal(65));
                  populateAttributeForRow(r, 65,resultSet.getDate(66));
                  populateAttributeForRow(r, 66,resultSet.getString(67));
                  populateAttributeForRow(r, 67,resultSet.getString(68));
                  populateAttributeForRow(r, 68,resultSet.getBigDecimal(69));
                  populateAttributeForRow(r, 69,resultSet.getString(70));*/

        } catch (SQLException s) {
            throw new JboException(s);
        }
        return r;
    }

    /**
     * Overridden framework method.
     *
     * Return true if the datasource has at least one more record to fetch.
     */
    protected boolean hasNextForCollection(Object qc) {
        ResultSet rs = getResultSet(qc);
        boolean nextOne = false;
        try {
            nextOne = rs.next();
            /*
      * When were at the end of the result set, mark the query collection
      * as "FetchComplete".
      */
            if (!nextOne) {
                setFetchCompleteForCollection(qc, true);
                /*
        * Close the result set, we're done with it
        */
                rs.close();
            }
        } catch (SQLException s) {
            throw new JboException(s);
        }
        return nextOne;
    }

    /**
     * Overridden framework method.
     *
     * The framework gives us a chance to clean up any resources related
     * to the datasource when a query collection is done being used.
     */
    protected void releaseUserDataForCollection(Object qc, Object rs) {
        /*
    * Ignore the ResultSet passed in since we've created our own.
    * Fetch the ResultSet from the User-Data context instead
    */
        ResultSet userDataRS = getResultSet(qc);
        if (userDataRS != null) {
            try {
                userDataRS.close();
            } catch (SQLException s) {
                /* Ignore */
            }
        }
        super.releaseUserDataForCollection(qc, rs);
    }

    /**
     * Overridden framework method
     *
     * Return the number of rows that would be returned by executing
     * the query implied by the datasource. This gives the developer a
     * chance to perform a fast count of the rows that would be retrieved
     * if all rows were fetched from the database. In the default implementation
     * the framework will perform a SELECT COUNT(*) FROM (...) wrapper query
     * to let the database return the count. This count might only be an estimate
     * depending on how resource-intensive it would be to actually count the rows.
     */
    public long getQueryHitCount(ViewRowSetImpl viewRowSet) {
        BigDecimal result =
            (BigDecimal)callStoredFunction(NUMBER, "TQC_CLIENTS_PKG.get_cnt_client_details(?,?)",
                                           null);
        String val = result.toString();
        long retVal = new Long(val);
        return retVal;
    }
    // ------------- PRIVATE METHODS ----------------


    /**
     * Return a JDBC ResultSet representing the REF CURSOR return
     * value from our stored package function.
     */
    private ResultSet retrieveRefCursor(Object qc, Object[] params) {
        ResultSet rs =
            (ResultSet)callStoredFunction(OracleTypes.CURSOR, "TQC_CLIENTS_PKG.get_client_detailsNotInGroup(?,?)",
                                          null);
        return rs;
    }

    private Object getNamedBindParamValue(String varName, Object[] params) {
        Object result = null;
        if (getBindingStyle() == SQLBuilder.BINDING_STYLE_ORACLE_NAME) {
            if (params != null) {
                for (Object param : params) {
                    Object[] nameValue = (Object[])param;
                    String name = (String)nameValue[0];
                    if (name.equals(varName)) {
                        return (String)nameValue[1];
                    }
                }
            }
        }
        throw new JboException("No bind variable named '" + varName + "'");
    }

    /**
     * Store a new result set in the query-collection-private user-data context
     */
    private void storeNewResultSet(Object qc, ResultSet rs) {
        ResultSet existingRs = getResultSet(qc);
        // If this query collection is getting reused, close out any previous rowset
        if (existingRs != null) {
            try {
                existingRs.close();
            } catch (SQLException s) {
            }
        }
        setUserDataForCollection(qc, rs);
        hasNextForCollection(qc); // Prime the pump with the first row.
    }

    /**
     * Retrieve the result set wrapper from the query-collection user-data
     */
    private ResultSet getResultSet(Object qc) {
        return (ResultSet)getUserDataForCollection(qc);
    }

    /**
     * Return either null or a new oracle.jbo.domain.Date
     */
    private static Date nullOrNewDate(Timestamp t) {
        return t != null ? new Date(t) : null;
    }

    /**
     * Return either null or a new oracle.jbo.domain.Number
     */
    private static Number nullOrNewNumber(BigDecimal b) {
        try {
            return b != null ? new Number(b) : null;
        } catch (SQLException s) {
        }
        return null;
    }
    //----------------[ Begin Helper Code ]------------------------------
    public static int NUMBER = Types.NUMERIC;
    public static int DATE = Types.DATE;
    public static int VARCHAR2 = Types.VARCHAR;

    /**
     * Simplifies calling a stored function with bind variables
     *
     * You can use the NUMBER, DATE, and VARCHAR2 constants in this
     * class to indicate the function return type for these three common types,
     * otherwise use one of the JDBC types in the java.sql.Types class.
     *
     * NOTE: If you want to invoke a stored procedure without any bind variables
     * ====  then you can just use the basic getDBTransaction().executeCommand()
     *
     * @param sqlReturnType JDBC datatype constant of function return value
     * @param stmt stored function statement
     * @param bindVars Object array of parameters
     * @return function return value as an Object
     */
    protected Object callStoredFunction(int sqlReturnType, String stmt,
                                        Object[] bindVars) {
        CallableStatement st = null;
        DBConnector connector = new DBConnector();
        if (!getDBTransaction().isConnected()) {
            getDBTransaction().connectToDataSource(connector.getDatabaseSource(),
                                                   true);
        }

        try {
            st =
 getDBTransaction().createCallableStatement("begin ? := " + stmt + "; end;",
                                            0);
            st.registerOutParameter(1, sqlReturnType);
            st.setBigDecimal(3,
                             session.getAttribute("grpCode") == null ? null :
                             new BigDecimal(session.getAttribute("grpCode").toString()));
            st.setBigDecimal(2, null);
            st.executeUpdate();
            return st.getObject(1);
        } catch (SQLException e) {
            throw new JboException(e);
        }

    }


    /* protected Object callStoredProcedure(int sqlReturnType, String stmt,
        Object[] bindVars) {
        CallableStatement st = null;
        DBConnector connector=new DBConnector();
        if(!getDBTransaction().isConnected()){
          getDBTransaction().connectToDataSource(connector.getDatabaseSource(), true);
        }

        try {
          st = getDBTransaction().createCallableStatement("begin  " + stmt +
                    "; end;", 0);
          st.registerOutParameter(1, sqlReturnType);
          st.setBigDecimal(2, (BigDecimal)session.getAttribute("productCode"));

         /* if (bindVars != null) {
            for (int z = 0; z < bindVars.length; z++) {
              st.setObject(z + 2, bindVars[z]);
            }
          }*/
    /*   st.executeUpdate();
          return st.getObject(1);
        }
        catch (SQLException e) {
          throw new JboException(e);
        }

      }*/

    /**getEstimatedRowCount - overridden for custom java data source support.
     */
    public long getEstimatedRowCount() {
        long value = super.getEstimatedRowCount();
        return value;
    }
}
